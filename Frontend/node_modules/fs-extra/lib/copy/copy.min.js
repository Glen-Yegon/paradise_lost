"use strict";const fs=require("../fs"),path=require("path"),{mkdirs:mkdirs}=require("../mkdirs"),{pathExists:pathExists}=require("../path-exists"),{utimesMillis:utimesMillis}=require("../util/utimes"),stat=require("../util/stat");async function copy(t,e,i={}){"function"==typeof i&&(i={filter:i}),i.clobber=!("clobber"in i)||!!i.clobber,i.overwrite="overwrite"in i?!!i.overwrite:i.clobber,i.preserveTimestamps&&"ia32"===process.arch&&process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n\tsee https://github.com/jprichardson/node-fs-extra/issues/269","Warning","fs-extra-WARN0001");const{srcStat:r,destStat:s}=await stat.checkPaths(t,e,"copy",i);await stat.checkParentPaths(t,r,e,"copy");if(!await runFilter(t,e,i))return;const n=path.dirname(e);await pathExists(n)||await mkdirs(n),await getStatsAndPerformCopy(s,t,e,i)}async function runFilter(t,e,i){return!i.filter||i.filter(t,e)}async function getStatsAndPerformCopy(t,e,i,r){const s=r.dereference?fs.stat:fs.lstat,n=await s(e);if(n.isDirectory())return onDir(n,t,e,i,r);if(n.isFile()||n.isCharacterDevice()||n.isBlockDevice())return onFile(n,t,e,i,r);if(n.isSymbolicLink())return onLink(t,e,i,r);if(n.isSocket())throw new Error(`Cannot copy a socket file: ${e}`);if(n.isFIFO())throw new Error(`Cannot copy a FIFO pipe: ${e}`);throw new Error(`Unknown file: ${e}`)}async function onFile(t,e,i,r,s){if(!e)return copyFile(t,i,r,s);if(s.overwrite)return await fs.unlink(r),copyFile(t,i,r,s);if(s.errorOnExist)throw new Error(`'${r}' already exists`)}async function copyFile(t,e,i,r){if(await fs.copyFile(e,i),r.preserveTimestamps){fileIsNotWritable(t.mode)&&await makeFileWritable(i,t.mode);const r=await fs.stat(e);await utimesMillis(i,r.atime,r.mtime)}return fs.chmod(i,t.mode)}function fileIsNotWritable(t){return!(128&t)}function makeFileWritable(t,e){return fs.chmod(t,128|e)}async function onDir(t,e,i,r,s){e||await fs.mkdir(r);const n=[];for await(const t of await fs.opendir(i)){const e=path.join(i,t.name),a=path.join(r,t.name);n.push(runFilter(e,a,s).then(t=>{if(t)return stat.checkPaths(e,a,"copy",s).then(({destStat:t})=>getStatsAndPerformCopy(t,e,a,s))}))}await Promise.all(n),e||await fs.chmod(r,t.mode)}async function onLink(t,e,i,r){let s=await fs.readlink(e);if(r.dereference&&(s=path.resolve(process.cwd(),s)),!t)return fs.symlink(s,i);let n=null;try{n=await fs.readlink(i)}catch(t){if("EINVAL"===t.code||"UNKNOWN"===t.code)return fs.symlink(s,i);throw t}if(r.dereference&&(n=path.resolve(process.cwd(),n)),stat.isSrcSubdir(s,n))throw new Error(`Cannot copy '${s}' to a subdirectory of itself, '${n}'.`);if(stat.isSrcSubdir(n,s))throw new Error(`Cannot overwrite '${n}' with '${s}'.`);return await fs.unlink(i),fs.symlink(s,i)}module.exports=copy;