"use strict";const fs=require("../fs"),path=require("path"),u=require("universalify").fromPromise;function getStats(t,r,e){const n=e.dereference?t=>fs.stat(t,{bigint:!0}):t=>fs.lstat(t,{bigint:!0});return Promise.all([n(t),n(r).catch(t=>{if("ENOENT"===t.code)return null;throw t})]).then(([t,r])=>({srcStat:t,destStat:r}))}function getStatsSync(t,r,e){let n;const a=e.dereference?t=>fs.statSync(t,{bigint:!0}):t=>fs.lstatSync(t,{bigint:!0}),i=a(t);try{n=a(r)}catch(t){if("ENOENT"===t.code)return{srcStat:i,destStat:null};throw t}return{srcStat:i,destStat:n}}async function checkPaths(t,r,e,n){const{srcStat:a,destStat:i}=await getStats(t,r,n);if(i){if(areIdentical(a,i)){const n=path.basename(t),s=path.basename(r);if("move"===e&&n!==s&&n.toLowerCase()===s.toLowerCase())return{srcStat:a,destStat:i,isChangingCase:!0};throw new Error("Source and destination must not be the same.")}if(a.isDirectory()&&!i.isDirectory())throw new Error(`Cannot overwrite non-directory '${r}' with directory '${t}'.`);if(!a.isDirectory()&&i.isDirectory())throw new Error(`Cannot overwrite directory '${r}' with non-directory '${t}'.`)}if(a.isDirectory()&&isSrcSubdir(t,r))throw new Error(errMsg(t,r,e));return{srcStat:a,destStat:i}}function checkPathsSync(t,r,e,n){const{srcStat:a,destStat:i}=getStatsSync(t,r,n);if(i){if(areIdentical(a,i)){const n=path.basename(t),s=path.basename(r);if("move"===e&&n!==s&&n.toLowerCase()===s.toLowerCase())return{srcStat:a,destStat:i,isChangingCase:!0};throw new Error("Source and destination must not be the same.")}if(a.isDirectory()&&!i.isDirectory())throw new Error(`Cannot overwrite non-directory '${r}' with directory '${t}'.`);if(!a.isDirectory()&&i.isDirectory())throw new Error(`Cannot overwrite directory '${r}' with non-directory '${t}'.`)}if(a.isDirectory()&&isSrcSubdir(t,r))throw new Error(errMsg(t,r,e));return{srcStat:a,destStat:i}}async function checkParentPaths(t,r,e,n){const a=path.resolve(path.dirname(t)),i=path.resolve(path.dirname(e));if(i===a||i===path.parse(i).root)return;let s;try{s=await fs.stat(i,{bigint:!0})}catch(t){if("ENOENT"===t.code)return;throw t}if(areIdentical(r,s))throw new Error(errMsg(t,e,n));return checkParentPaths(t,r,i,n)}function checkParentPathsSync(t,r,e,n){const a=path.resolve(path.dirname(t)),i=path.resolve(path.dirname(e));if(i===a||i===path.parse(i).root)return;let s;try{s=fs.statSync(i,{bigint:!0})}catch(t){if("ENOENT"===t.code)return;throw t}if(areIdentical(r,s))throw new Error(errMsg(t,e,n));return checkParentPathsSync(t,r,i,n)}function areIdentical(t,r){return r.ino&&r.dev&&r.ino===t.ino&&r.dev===t.dev}function isSrcSubdir(t,r){const e=path.resolve(t).split(path.sep).filter(t=>t),n=path.resolve(r).split(path.sep).filter(t=>t);return e.every((t,r)=>n[r]===t)}function errMsg(t,r,e){return`Cannot ${e} '${t}' to a subdirectory of itself, '${r}'.`}module.exports={checkPaths:u(checkPaths),checkPathsSync:checkPathsSync,checkParentPaths:u(checkParentPaths),checkParentPathsSync:checkParentPathsSync,isSrcSubdir:isSrcSubdir,areIdentical:areIdentical};