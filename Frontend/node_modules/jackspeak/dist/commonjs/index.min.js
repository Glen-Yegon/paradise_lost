"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.jack=exports.Jack=exports.isConfigOption=exports.isConfigOptionOfType=exports.isConfigType=void 0;const node_util_1=require("node:util"),cliui_1=__importDefault(require("@isaacs/cliui")),node_path_1=require("node:path"),isConfigType=e=>"string"==typeof e&&("string"===e||"number"===e||"boolean"===e);exports.isConfigType=isConfigType;const isValidValue=(e,t,i)=>i?!!Array.isArray(e)&&!e.some(e=>!isValidValue(e,t,!1)):!Array.isArray(e)&&typeof e===t,isValidOption=(e,t)=>!!t&&(Array.isArray(e)?e.every(e=>isValidOption(e,t)):t.includes(e)),isConfigOptionOfType=(e,t,i)=>!!e&&"object"==typeof e&&(0,exports.isConfigType)(e.type)&&e.type===t&&!!e.multiple===i;exports.isConfigOptionOfType=isConfigOptionOfType;const isConfigOption=(e,t,i)=>(0,exports.isConfigOptionOfType)(e,t,i)&&undefOrType(e.short,"string")&&undefOrType(e.description,"string")&&undefOrType(e.hint,"string")&&undefOrType(e.validate,"function")&&("boolean"===e.type?void 0===e.validOptions:undefOrTypeArray(e.validOptions,e.type))&&(void 0===e.default||isValidValue(e.default,t,i));exports.isConfigOption=isConfigOption;const isHeading=e=>"heading"===e.type,isDescription=e=>"description"===e.type,width=Math.min(process?.stdout?.columns??80,80),indent=e=>2*(e-1),toEnvKey=(e,t)=>[e,t.replace(/[^a-zA-Z0-9]+/g," ")].join(" ").trim().toUpperCase().replace(/ /g,"_"),toEnvVal=(e,t="\n")=>{const i="string"==typeof e?e:"boolean"==typeof e?e?"1":"0":"number"==typeof e?String(e):Array.isArray(e)?e.map(e=>toEnvVal(e)).join(t):void 0;if("string"!=typeof i)throw new Error(`could not serialize value to environment: ${JSON.stringify(e)}`,{cause:{code:"JACKSPEAK"}});return i},fromEnvVal=(e,t,i,n="\n")=>i?e?e.split(n).map(e=>fromEnvVal(e,t,!1)):[]:"string"===t?e:"boolean"===t?"1"===e:+e.trim(),undefOrType=(e,t)=>void 0===e||typeof e===t,undefOrTypeArray=(e,t)=>void 0===e||Array.isArray(e)&&e.every(e=>typeof e===t),valueType=e=>"string"==typeof e?"string":"boolean"==typeof e?"boolean":"number"==typeof e?"number":Array.isArray(e)?`${joinTypes([...new Set(e.map(e=>valueType(e)))])}[]`:`${e.type}${e.multiple?"[]":""}`,joinTypes=e=>1===e.length&&"string"==typeof e[0]?e[0]:`(${e.join("|")})`,validateFieldMeta=(e,t)=>{if(t){if(void 0!==e.type&&e.type!==t.type)throw new TypeError("invalid type",{cause:{found:e.type,wanted:[t.type,void 0]}});if(void 0!==e.multiple&&!!e.multiple!==t.multiple)throw new TypeError("invalid multiple",{cause:{found:e.multiple,wanted:[t.multiple,void 0]}});return t}if(!(0,exports.isConfigType)(e.type))throw new TypeError("invalid type",{cause:{found:e.type,wanted:["string","number","boolean"]}});return{type:e.type,multiple:!!e.multiple}},validateField=(e,t,i)=>{const n=(e,i)=>{if(!undefOrTypeArray(i,t))throw new TypeError("invalid validOptions",{cause:{found:i,wanted:valueType({type:t,multiple:!0})}});if(void 0!==e&&void 0!==i){if(!(Array.isArray(e)?e.every(e=>i.includes(e)):i.includes(e)))throw new TypeError("invalid default value not in validOptions",{cause:{found:e,wanted:i}})}};if(void 0!==e.default&&!isValidValue(e.default,t,i))throw new TypeError("invalid default value",{cause:{found:e.default,wanted:valueType({type:t,multiple:i})}});if((0,exports.isConfigOptionOfType)(e,"number",!1)||(0,exports.isConfigOptionOfType)(e,"number",!0))n(e.default,e.validOptions);else if((0,exports.isConfigOptionOfType)(e,"string",!1)||(0,exports.isConfigOptionOfType)(e,"string",!0))n(e.default,e.validOptions);else if((0,exports.isConfigOptionOfType)(e,"boolean",!1)||(0,exports.isConfigOptionOfType)(e,"boolean",!0)){if(void 0!==e.hint)throw new TypeError("cannot provide hint for flag");if(void 0!==e.validOptions)throw new TypeError("cannot provide validOptions for flag")}return e},toParseArgsOptionsConfig=e=>Object.entries(e).reduce((t,[i,n])=>{const o={type:"string",multiple:!!n.multiple,..."string"==typeof n.short?{short:n.short}:void 0},s=(e,t)=>{void 0!==e&&(o.default=t(e))};return(0,exports.isConfigOption)(n,"number",!1)?s(n.default,String):(0,exports.isConfigOption)(n,"number",!0)?s(n.default,e=>e.map(e=>String(e))):(0,exports.isConfigOption)(n,"string",!1)||(0,exports.isConfigOption)(n,"string",!0)?s(n.default,e=>e):((0,exports.isConfigOption)(n,"boolean",!1)||(0,exports.isConfigOption)(n,"boolean",!0))&&(o.type="boolean",s(n.default,e=>e),i.startsWith("no-")||e[`no-${i}`]||(t[`no-${i}`]={type:"boolean",multiple:!!n.multiple})),t[i]=o,t},{});class Jack{#e;#t;#i;#n=[];#o;#s;#r;#a;#l;constructor(e={}){this.#i=e,this.#r=!1!==e.allowPositionals,this.#o=void 0===this.#i.env?process.env:this.#i.env,this.#s=e.envPrefix,this.#e=Object.create(null),this.#t=Object.create(null)}get definitions(){return this.#e}get shorts(){return this.#t}get jackOptions(){return this.#i}get usageFields(){return this.#n}setConfigValues(e,t=""){try{this.validate(e)}catch(e){if(t&&e instanceof Error){const i="object"==typeof e.cause?e.cause:{};e.cause={...i,path:t},Error.captureStackTrace(e,this.setConfigValues)}throw e}for(const[t,i]of Object.entries(e)){const e=this.#e[t];if(!e)throw new Error("unexpected field in config set: "+t,{cause:{code:"JACKSPEAK",found:t}});e.default=i}return this}parse(e=process.argv){this.loadEnvDefaults();const t=this.parseRaw(e);return this.applyDefaults(t),this.writeEnv(t),t}loadEnvDefaults(){if(this.#s)for(const[e,t]of Object.entries(this.#e)){const i=toEnvKey(this.#s,e),n=this.#o[i];void 0!==n&&(t.default=fromEnvVal(n,t.type,!!t.multiple,t.delim))}}applyDefaults(e){for(const[t,i]of Object.entries(this.#e))void 0===i.default||t in e.values||(e.values[t]=i.default)}parseRaw(e){e===process.argv&&(e=e.slice(void 0!==process._eval?1:2));const t=(0,node_util_1.parseArgs)({args:e,options:toParseArgsOptionsConfig(this.#e),strict:!1,allowPositionals:this.#r,tokens:!0}),i={values:{},positionals:[]};for(const n of t.tokens)if("positional"===n.kind){if(i.positionals.push(n.value),this.#i.stopAtPositional||this.#i.stopAtPositionalTest?.(n.value)){i.positionals.push(...e.slice(n.index+1));break}}else if("option"===n.kind){let e;if(n.name.startsWith("no-")){const t=this.#e[n.name],i=n.name.substring(3),o=this.#e[i];o&&"boolean"===o.type&&(!t||"boolean"===t.type&&!!t.multiple==!!o.multiple)&&(e=!1,n.name=i)}const t=this.#e[n.name];if(!t)throw new Error(`Unknown option '${n.rawName}'. To specify a positional argument starting with a '-', place it at the end of the command after '--', as in '-- ${n.rawName}'`,{cause:{code:"JACKSPEAK",found:n.rawName+(n.value?`=${n.value}`:"")}});if(void 0===e)if(void 0===n.value){if("boolean"!==t.type)throw new Error(`No value provided for ${n.rawName}, expected ${t.type}`,{cause:{code:"JACKSPEAK",name:n.rawName,wanted:valueType(t)}});e=!0}else{if("boolean"===t.type)throw new Error(`Flag ${n.rawName} does not take a value, received '${n.value}'`,{cause:{code:"JACKSPEAK",found:n}});if("string"===t.type)e=n.value;else if(e=+n.value,e!=e)throw new Error(`Invalid value '${n.value}' provided for '${n.rawName}' option, expected number`,{cause:{code:"JACKSPEAK",name:n.rawName,found:n.value,wanted:"number"}})}if(t.multiple){const t=i.values,o=t[n.name]??[];t[n.name]=o,o.push(e)}else{i.values[n.name]=e}}for(const[e,t]of Object.entries(i.values)){const i=this.#e[e]?.validate,n=this.#e[e]?.validOptions,o=n&&!isValidOption(t,n)?{name:e,found:t,validOptions:n}:i&&!i(t)?{name:e,found:t}:void 0;if(o)throw new Error(`Invalid value provided for --${e}: ${JSON.stringify(t)}`,{cause:{...o,code:"JACKSPEAK"}})}return i}#p(e,t,i=e){if(!e.startsWith("no-")||"boolean"!=typeof t)return;const n=e.substring(3);if(this.#p(n,t,i),"boolean"===this.#e[n]?.type)throw new Error(`do not set '${i}', instead set '${n}' as desired.`,{cause:{code:"JACKSPEAK",found:i,wanted:n}})}validate(e){if(!e||"object"!=typeof e)throw new Error("Invalid config: not an object",{cause:{code:"JACKSPEAK",found:e}});const t=e;for(const i in e){const e=t[i];if(void 0===e)continue;this.#p(i,e);const n=this.#e[i];if(!n)throw new Error(`Unknown config option: ${i}`,{cause:{code:"JACKSPEAK",found:i}});if(!isValidValue(e,n.type,!!n.multiple))throw new Error(`Invalid value ${valueType(e)} for ${i}, expected ${valueType(n)}`,{cause:{code:"JACKSPEAK",name:i,found:e,wanted:valueType(n)}});const o=n.validOptions&&!isValidOption(e,n.validOptions)?{name:i,found:e,validOptions:n.validOptions}:n.validate&&!n.validate(e)?{name:i,found:e}:void 0;if(o)throw new Error(`Invalid config value for ${i}: ${e}`,{cause:{...o,code:"JACKSPEAK"}})}}writeEnv(e){if(this.#o&&this.#s)for(const[t,i]of Object.entries(e.values)){const e=this.#e[t];this.#o[toEnvKey(this.#s,t)]=toEnvVal(i,e?.delim)}}heading(e,t,{pre:i=!1}={}){return void 0===t&&(t=this.#n.some(e=>isHeading(e))?2:1),this.#n.push({type:"heading",text:e,level:t,pre:i}),this}description(e,{pre:t}={}){return this.#n.push({type:"description",text:e,pre:t}),this}num(e){return this.#d(e,"number",!1)}numList(e){return this.#d(e,"number",!0)}opt(e){return this.#d(e,"string",!1)}optList(e){return this.#d(e,"string",!0)}flag(e){return this.#d(e,"boolean",!1)}flagList(e){return this.#d(e,"boolean",!0)}addFields(e){return this.#u(this,e)}#d(e,t,i){return this.#u(this,e,{type:t,multiple:i})}#u(e,t,i){return Object.assign(e.#e,Object.fromEntries(Object.entries(t).map(([t,n])=>{this.#f(t,n);const{type:o,multiple:s}=validateFieldMeta(n,i),r={...n,type:o,multiple:s};return validateField(r,o,s),e.#n.push({type:"config",name:t,value:r}),[t,r]}))),e}#f(e,t){if(!/^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/.test(e))throw new TypeError(`Invalid option name: ${e}, must be '-' delimited ASCII alphanumeric`);if(this.#e[e])throw new TypeError(`Cannot redefine option ${t}`);if(this.#t[e])throw new TypeError(`Cannot redefine option ${e}, already in use for ${this.#t[e]}`);if(t.short){if(!/^[a-zA-Z0-9]$/.test(t.short))throw new TypeError(`Invalid ${e} short option: ${t.short}, must be 1 ASCII alphanumeric character`);if(this.#t[t.short])throw new TypeError(`Invalid ${e} short option: ${t.short}, already in use for ${this.#t[t.short]}`);this.#t[t.short]=e,this.#t[e]=e}}usage(){if(this.#a)return this.#a;let e=1;const t=(0,cliui_1.default)({width:width}),i=this.#n[0];let n="heading"===i?.type?1:0;if("heading"===i?.type&&t.div({padding:[0,0,0,0],text:normalize(i.text)}),t.div({padding:[0,0,0,0],text:"Usage:"}),this.#i.usage)t.div({text:this.#i.usage,padding:[0,0,0,2]});else{const e=(0,node_path_1.basename)(String(process.argv[1])),i=[],n=[],o=[],s=[];for(const[e,t]of Object.entries(this.#e))t.short?"boolean"===t.type?i.push(t.short):n.push([t.short,t.hint||e]):"boolean"===t.type?o.push(e):s.push([e,t.hint||e]);const r=`${e}${i.length?" -"+i.join(""):""}${n.map(([e,t])=>` --${e}=<${t}>`).join("")}${o.map(e=>` --${e}`).join("")}${s.map(([e,t])=>` --${e}=<${t}>`).join("")}`.trim();t.div({text:r,padding:[0,0,0,2]})}t.div({padding:[0,0,0,0],text:""});const o=this.#n[n];if(o&&isDescription(o)){const e=normalize(o.text,o.pre);n++,t.div({padding:[0,0,0,0],text:e}),t.div({padding:[0,0,0,0],text:""})}const{rows:s,maxWidth:r}=this.#h(n);for(const i of s)if(i.left){const n=indent(Math.max(e,2));i.left.length>r-3?(t.div({text:i.left,padding:[0,0,0,n]}),t.div({text:i.text,padding:[0,0,0,r]})):t.div({text:i.left,padding:[0,1,0,n],width:r},{padding:[0,0,0,0],text:i.text}),i.skipLine&&t.div({padding:[0,0,0,0],text:""})}else if(isHeading(i)){const{level:n}=i;e=n;const o=n<=2?1:0;t.div({...i,padding:[0,0,o,indent(n)]})}else t.div({...i,padding:[0,0,1,indent(e+1)]});return this.#a=t.toString()}usageMarkdown(){if(this.#l)return this.#l;const e=[];let t=1;const i=this.#n[0];let n="heading"===i?.type?1:0;if("heading"===i?.type&&e.push(`# ${normalizeOneLine(i.text)}`),e.push("Usage:"),this.#i.usage)e.push(normalizeMarkdown(this.#i.usage,!0));else{const t=(0,node_path_1.basename)(String(process.argv[1])),i=[],n=[],o=[],s=[];for(const[e,t]of Object.entries(this.#e))t.short?"boolean"===t.type?i.push(t.short):n.push([t.short,t.hint||e]):"boolean"===t.type?o.push(e):s.push([e,t.hint||e]);const r=`${t}${i.length?" -"+i.join(""):""}${n.map(([e,t])=>` --${e}=<${t}>`).join("")}${o.map(e=>` --${e}`).join("")}${s.map(([e,t])=>` --${e}=<${t}>`).join("")}`.trim();e.push(normalizeMarkdown(r,!0))}const o=this.#n[n];o&&isDescription(o)&&(e.push(normalizeMarkdown(o.text,o.pre)),n++);const{rows:s}=this.#h(n);for(const i of s)if(i.left)e.push("#".repeat(t+1)+" "+normalizeOneLine(i.left,!0)),i.text&&e.push(normalizeMarkdown(i.text));else if(isHeading(i)){const{level:n}=i;t=n,e.push(`${"#".repeat(t)} ${normalizeOneLine(i.text,i.pre)}`)}else e.push(normalizeMarkdown(i.text,!!i.pre));return this.#l=e.join("\n\n")+"\n"}#h(e){let t,i=Math.max(12,Math.min(26,Math.floor(width/3))),n=8;const o=[];for(const s of this.#n.slice(e)){if("config"!==s.type){"config"===t?.type&&(t.skipLine=!0),t=void 0,s.text=normalize(s.text,!!s.pre),o.push(s);continue}const{value:e}=s,r=e.description||"",a=e.multiple?"Can be set multiple times":"",l=e.validOptions?.length?`Valid options:${e.validOptions.map(e=>` ${JSON.stringify(e)}`)}`:"",p=r.includes("\n")?"\n\n":"\n",d=[l,a].join(p).trim(),u=(normalize(r)+p+d).trim(),f=e.hint||("number"===e.type?"n":"string"===e.type?s.name:void 0),h=e.short?"boolean"===e.type?`-${e.short} `:`-${e.short}<${f}> `:"",c="boolean"===e.type?`${h}--${s.name}`:`${h}--${s.name}=<${f}>`,g={text:u,left:c,type:"config"};u.length>width-i&&(g.skipLine=!0),t&&c.length>i&&(t.skipLine=!0),t=g;const v=c.length+4;v>n&&v<i&&(n=v),o.push(g)}return{rows:o,maxWidth:n}}toJSON(){return Object.fromEntries(Object.entries(this.#e).map(([e,t])=>[e,{type:t.type,...t.multiple?{multiple:!0}:{},...t.delim?{delim:t.delim}:{},...t.short?{short:t.short}:{},...t.description?{description:normalize(t.description)}:{},...t.validate?{validate:t.validate}:{},...t.validOptions?{validOptions:t.validOptions}:{},...void 0!==t.default?{default:t.default}:{},...t.hint?{hint:t.hint}:{}}]))}[node_util_1.inspect.custom](e,t){return`Jack ${(0,node_util_1.inspect)(this.toJSON(),t)}`}}exports.Jack=Jack;const jack=(e={})=>new Jack(e);exports.jack=jack;const normalize=(e,t=!1)=>t?e.split("\n").map(e=>`​${e}`).join("\n"):e.split(/^\s*```\s*$/gm).map((e,t)=>{if(t%2==1){if(!e.trim())return"```\n```\n";const t=e.split("\n");t.pop(),t.shift();const i=t.reduce((e,t)=>{const i=t.match(/^\s*/)?.[0]??"";return i.length?Math.min(i.length,e):e},1/0),n=isFinite(i)?i:0;return"\n```\n"+t.map(e=>`​${e.substring(n)}`).join("\n")+"\n```\n"}return e.replace(/([^\n])\n[ \t]*([^\n])/g,(e,t,i)=>/^[-*]/.test(i)?`${t}\n${i}`:`${t} ${i}`).replace(/([^\n])[ \t]+([^\n])/g,"$1 $2").replace(/\n{3,}/g,"\n\n").replace(/\n[ \t]+/g,"\n").trim()}).join("\n"),normalizeMarkdown=(e,t=!1)=>{const i=normalize(e,t).replace(/\\/g,"\\\\");return t?`\`\`\`\n${i.replace(/\u200b/g,"")}\n\`\`\``:i.replace(/\n +/g,"\n").trim()},normalizeOneLine=(e,t=!1)=>{const i=normalize(e,t).replace(/[\s\u200b]+/g," ").trim();return t?`\`${i}\``:i};